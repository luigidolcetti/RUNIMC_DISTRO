% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/engine_alligatorMap.R
\name{alligatorMap}
\alias{alligatorMap}
\title{alligatorMap}
\usage{
alligatorMap(
  fn_srt,
  fn_radius = 10,
  fn_Nspikes = 4,
  fn_minArea = 10,
  fn_maxArea = 100,
  fn_minRoundness = 0.6,
  fn_maxRoundness = 0.8,
  fn_coverage = 0.3,
  fn_seedOutScore = 10,
  fn_cycleWindow = 1,
  fn_discoverTreshold = 0.01,
  fn_adaptative = T,
  fn_areaAdaptRate = 0,
  fn_roundnessAdaptRate = 0,
  fn_segmentAlg = c("sign_simple", "sign_extended", "quadratic"),
  fn_fusion = T,
  fn_targetArea = 50,
  fn_maxNetworkSize = 4,
  fn_inflateDeflate = 0.1,
  fn_favourForeing = T,
  fn_returnKinetic = F,
  fn_returnRasters = F
)
}
\arguments{
\item{fn_srt}{raster, map to be segmented, should represent some meaningful parameter
such as the position of each single pixel as predicted by the function.
\link{randomOnions} or \link{randomOnions_parallel}.}

\item{fn_radius}{numeric scalar, length of radius.}

\item{fn_Nspikes}{numeric scalar, number of radii to scan.}

\item{fn_minArea}{numeric scalar, minimum polygon area.}

\item{fn_maxArea}{numeric scalar, maximum polygon area.}

\item{fn_minRoundness}{numeric scalar, minimum polygon roundness.}

\item{fn_maxRoundness}{numeric scalar, maximum polygon roundness.}

\item{fn_coverage}{numeric scalar, pixel coverage threshold used to decide
whether to assign or not a pixel to a forming polygon}

\item{fn_seedOutScore}{numeric scalar, maximum number of times a pixel
can be used as seed before being either included in a polygon or taken
out of the pool of considered pixels.}

\item{fn_cycleWindow}{numeric scalar, number of thousand pixels to scan
before applying stringency reduction.}

\item{fn_adaptative}{logic scalar, apply stringency reduction (TRUE, default)
or not.}

\item{fn_areaAdaptRate}{numeric scalar (0-1), rate of stringency reduction
for area constrain.}

\item{fn_roundnessAdaptRate}{numeric scalar (0-1), rate of stringency reduction
for roundness constrain.}

\item{fn_segmentAlg}{character, method to guess the edge of one radius, can
be sign_simple, sign_extended, or quadratic.}

\item{fn_fusion}{logic scalar, try to optimize segmentation aggregating
adjacent polygons (TRUE, default).}

\item{fn_targetArea}{numeric or character scalar, if numeric is the ideal
area to target when aggregating adjacent polygons. If a character is
provided that can be one among: predicted_mean, predicted_median, predicted_mode,
predicted_max, or predicted_middle, in brief the target area is calculated
from the discovered polygon accordingly to the specified statistics.}

\item{fn_maxNetworkSize}{numeric scalar, maximum extension of the network
of adjacent polygons that needs to be evaluated for fusion.}

\item{fn_inflateDeflate}{numeric scalar, fraction of pixel to inflate and
deflate a fusion polygon in order to fix geometrical abnormalities.}

\item{fn_favourForeing}{logic scalar, variation in the edge detection, if
one radius invade an area of pixels that are not included in the pool of
pixels that are considered, the edge is forced on the edge between
considered/ foreign pixels (TRUE, default).}

\item{fn_returnKinetic}{logic scalar, return a dataframe with segmentation
statistics and kinetic of polygon discovery (TRUE, can slow the segmentation
process, therefor default is set to FALSE)}

\item{fn_returnRasters}{logic scalar, return a number of raster maps representing
the bitmap version of polygons and the map of included and excluded pixels.}

\item{fn_discoveryTreshold}{(not implemented).}
}
\description{
segmentation engine function that evaluates the profile of a number of radii
around seed pixels.
}
